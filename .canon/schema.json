{
  "project": {
    "name": "LLMProxy",
    "version": "1.0.0",
    "description": "面向大模型服务的高性能网关，支持流式/非流式无缝代理 + 异步用量计量",
    "language": "Go",
    "architecture": "单体架构"
  },
  "modules": {
    "cmd": {
      "name": "应用入口",
      "path": "cmd/main.go",
      "documentation": "程序主入口，负责：1. 解析命令行参数（配置文件路径）2. 加载配置 3. 初始化各模块 4. 启动 HTTP 服务器 5. 注册路由（/metrics、/health、代理路由）",
      "dependencies": ["config", "proxy", "metrics"]
    },
    "config": {
      "name": "配置管理模块",
      "path": "internal/config/",
      "documentation": "负责配置文件的解析和管理。配置项包括：1. 监听地址（listen）2. 后端列表（backends：url、weight）3. Webhook 配置（usage_hook：enabled、url、timeout、retry）4. 健康检查配置（health_check：interval、path）。使用 YAML 格式，通过 gopkg.in/yaml.v3 解析",
      "files": {
        "config.go": "定义 Config 结构体和 Load 函数，支持从文件路径加载配置"
      }
    },
    "proxy": {
      "name": "核心代理引擎",
      "path": "internal/proxy/",
      "documentation": "核心模块，负责请求代理和用量收集。关键实现：1. 仅处理 /v1/chat/completions 和 /v1/completions 路径 2. 读取请求体并解析 stream 参数 3. 通过负载均衡器选择后端 4. 使用 io.Copy 零缓冲转发响应（流式：text/event-stream，非流式：application/json）5. 请求结束后启动 goroutine 异步收集用量并上报",
      "files": {
        "handler.go": "实现 NewHandler 函数，返回 http.HandlerFunc。处理请求代理的主流程，包括：请求验证、body 读取、stream 参数解析、后端选择、请求转发、响应透传、异步用量上报触发",
        "usage_hook.go": "实现用量收集和 Webhook 上报。包含：1. collectUsage 函数：从响应中提取 usage 字段（prompt_tokens、completion_tokens、total_tokens）2. SendUsageWebhook 函数：通过 HTTP POST 发送用量数据到配置的 Webhook URL，支持超时和重试"
      }
    },
    "lb": {
      "name": "负载均衡器",
      "path": "internal/lb/",
      "documentation": "负载均衡模块，支持多种策略。功能：1. 维护后端列表 2. 根据权重选择后端 3. 健康检查（定期探测后端 /health 接口）4. 自动摘除不健康节点 5. 线程安全（使用 sync.Mutex）6. 支持多种负载均衡策略（轮询、最少连接数、延迟优先）",
      "files": {
        "balancer.go": "定义 LoadBalancer 接口和 Backend 结构体。接口方法：Next（选择后端）、UpdateHealth（更新健康状态）、RecordResult（记录请求结果）",
        "roundrobin.go": "实现轮询负载均衡器。包含 RoundRobin 结构体和 Next 方法。根据权重轮询选择后端",
        "least_connections.go": "实现最少连接数负载均衡器。维护每个后端的当前并发数，选择并发数最少的后端。适合长连接场景",
        "latency_based.go": "实现延迟优先负载均衡器。维护每个后端的平均延迟（使用指数移动平均 EMA），选择延迟最低的后端。适合性能敏感场景"
      }
    },
    "routing": {
      "name": "智能路由模块",
      "path": "internal/routing/",
      "documentation": "智能路由模块，负责模型映射、重试、故障转移。功能：1. 模型名映射（用户友好名称 -> 实际模型）2. 自动重试（指数退避）3. 故障转移（主后端失败切换到备用）4. 与负载均衡器集成 5. 与健康检查集成",
      "files": {
        "router.go": "路由器主逻辑。包含 Router 结构体、ProxyWithRetry（重试逻辑）、ProxyWithFallback（故障转移逻辑）、MapModel（模型映射）方法",
        "config.go": "路由配置结构体。包含 RoutingConfig、RetryConfig、FallbackRule 等结构体定义",
        "retry.go": "重试逻辑实现。指数退避算法，可配置重试次数、初始等待时间、最大等待时间、退避倍数。判断是否应该重试（网络错误、超时、5xx 错误重试，4xx 不重试）"
      }
    },
    "auth": {
      "name": "鉴权模块",
      "path": "internal/auth/",
      "documentation": "API Key 鉴权模块。功能：1. Key 验证（格式、状态、过期时间）2. IP 白名单/黑名单检查 3. 额度管理（Token 配额、重置周期）4. 模型访问权限控制 5. 支持多种存储方式（配置文件、Redis）",
      "files": {
        "middleware.go": "鉴权中间件。拦截请求，验证 API Key，检查权限和额度。验证失败返回 401/403，额度不足返回 429",
        "keystore.go": "Key 存储接口和实现。定义 KeyStore 接口（Get、Update、IncrementUsedQuota 等方法）。实现 FileKeyStore（配置文件存储）和 RedisKeyStore（Redis 存储）",
        "models.go": "数据结构定义。包含 APIKey 结构体（Key、Name、UserID、Status、TotalQuota、UsedQuota、AllowedModels、AllowedIPs 等字段）",
        "quota.go": "额度管理逻辑。包含 DeductQuota（扣减额度）、ResetQuotaIfNeeded（按周期重置额度）、CheckQuota（检查额度是否充足）方法",
        "ip.go": "IP 控制逻辑。包含 CheckIPAllowed（检查 IP 是否允许访问）、ParseCIDR（解析 CIDR）方法"
      }
    },
    "ratelimit": {
      "name": "限流模块",
      "path": "internal/ratelimit/",
      "documentation": "限流模块，支持多层级限流。功能：1. 全局限流（保护推理服务）2. API Key 级限流（防止滥用）3. 并发数限制 4. Token 速率限制（TPM）5. 使用令牌桶算法 6. 支持 Redis 分布式限流",
      "files": {
        "middleware.go": "限流中间件。包含 RateLimitMiddleware（请求级限流）、TokenRateLimitMiddleware（Token 级限流）。设置标准 HTTP 响应头（X-RateLimit-Limit、X-RateLimit-Remaining 等）",
        "limiter.go": "限流器接口和实现。定义 RateLimiter 接口（Allow、AllowN、Remaining 等方法）。实现 RedisRateLimiter（基于 Redis）和 MemoryRateLimiter（基于内存）",
        "token_bucket.go": "令牌桶算法实现。使用 Redis Lua 脚本实现原子操作。支持突发流量（burst_size）",
        "config.go": "限流配置结构体。包含 RateLimitConfig、GlobalRateLimit、KeyRateLimit 等结构体定义",
        "concurrent.go": "并发数限制实现。使用 Redis 计数器跟踪当前并发数。请求开始时增加计数，结束时减少计数"
      }
    },
    "metrics": {
      "name": "监控指标模块",
      "path": "internal/metrics/",
      "documentation": "Prometheus 监控指标模块。提供的指标：1. llmproxy_requests_total（请求总数，标签：path、stream、backend、status）2. llmproxy_latency_ms（延迟直方图）3. llmproxy_webhook_success_total（Webhook 成功数）4. llmproxy_webhook_failure_total（Webhook 失败数）5. llmproxy_usage_tokens_total（token 使用量，标签：type=prompt/completion）",
      "files": {
        "metrics.go": "定义 Prometheus 指标并注册。提供 RecordRequest、RecordUsage、RecordWebhook 等函数，以及 Handler 函数用于暴露 /metrics 接口"
      }
    }
  },
  "deployment": {
    "docker": {
      "documentation": "Docker 部署方案。Dockerfile 使用多阶段构建：1. builder 阶段：基于 golang:1.22，编译生成二进制 2. 运行阶段：基于 alpine:latest，仅包含二进制和配置文件。docker-compose.yml 包含 vLLM 和 LLMProxy 服务，vLLM 需启用 --return-detailed-tokens 参数"
    },
    "kubernetes": {
      "documentation": "Kubernetes 部署方案。提供 Helm Chart，包含：1. Deployment（支持副本数配置）2. Service（ClusterIP）3. ConfigMap（配置注入）4. ServiceMonitor（Prometheus 集成）。values.yaml 支持自定义镜像、副本数、后端列表、Webhook 配置等"
    }
  },
  "configuration": {
    "format": "YAML",
    "example": {
      "listen": ":8000",
      "backends": [
        {"url": "http://vllm:8000", "weight": 5},
        {"url": "http://tgi:8081", "weight": 3}
      ],
      "usage_hook": {
        "enabled": true,
        "url": "https://your-billing.com/llm-usage",
        "timeout": "1s",
        "retry": 2
      },
      "health_check": {
        "interval": "10s",
        "path": "/health"
      }
    }
  },
  "monitoring": {
    "prometheus": {
      "documentation": "Prometheus 监控集成。LLMProxy 暴露 /metrics 接口，提供请求量、延迟、Webhook 状态等指标。支持通过 ServiceMonitor 自动发现"
    },
    "grafana": {
      "documentation": "Grafana 监控面板。提供预配置的 dashboard.json，包含：1. 请求速率面板 2. P99 延迟面板 3. Webhook 成功率面板 4. Token 使用量面板 5. 后端健康状态面板"
    }
  },
  "features": {
    "streaming": {
      "enabled": true,
      "documentation": "零缓冲流式传输。通过 io.Copy 实现，支持 SSE（Server-Sent Events）协议。自动识别请求中的 stream 参数，流式请求设置 Content-Type: text/event-stream"
    },
    "load_balancing": {
      "enabled": true,
      "strategy": "round_robin",
      "documentation": "负载均衡策略为轮询（Round Robin），支持权重配置。健康检查每 10 秒探测一次后端 /health 接口，不健康节点自动摘除。Phase 2 将扩展支持：最少连接数（least_connections）、延迟优先（latency_based）策略"
    },
    "usage_metering": {
      "enabled": true,
      "async": true,
      "documentation": "异步用量计量。请求结束后启动 goroutine 收集用量数据（从响应的 usage 字段提取），通过 HTTP Webhook 上报。上报失败仅记录日志，不影响主流程。支持的后端：vLLM（需启用 --return-detailed-tokens）、TGI（默认支持）"
    },
    "intelligent_routing": {
      "enabled": true,
      "documentation": "智能路由与故障转移。功能包括：1. 模型映射（用户友好名称 -> 实际模型名）2. 自动重试（指数退避策略，可配置重试次数和超时）3. 故障转移（主后端失败自动切换到备用后端，支持多级 fallback）4. 健康检查集成（自动摘除不健康节点）。配置示例见 docs/design-intelligent-routing.md",
      "components": {
        "model_mapping": "将用户请求的模型名映射到实际后端模型，支持模型别名。例如：llama-3-70b -> llama-3-70b-instruct",
        "retry": "请求失败后自动重试，使用指数退避策略（initial_wait * multiplier^attempt）。可配置最大重试次数、初始等待时间、最大等待时间、退避倍数",
        "fallback": "主后端失败后自动切换到备用后端。支持多级 fallback，可按模型配置不同的 fallback 规则。与健康检查集成，自动跳过不健康节点",
        "load_balance_strategies": "扩展负载均衡策略：1. round_robin（轮询，已实现）2. least_connections（最少连接数）3. latency_based（延迟优先）"
      }
    },
    "authentication": {
      "enabled": true,
      "documentation": "基础 API Key 鉴权。功能包括：1. API Key 验证（格式：sk-llmproxy-{32位随机字符}）2. IP 白名单/黑名单（CIDR 格式）3. 简单额度控制（Token 配额、重置周期）4. 模型访问权限控制 5. 过期时间检查。存储方式：配置文件（file）或 Redis。配置示例见 docs/design-api-key-management.md",
      "components": {
        "key_validation": "验证 API Key 是否存在、是否启用、是否过期。Key 格式：sk-llmproxy-{32位随机字符}",
        "ip_control": "IP 白名单/黑名单控制，支持 CIDR 格式。优先检查黑名单，再检查白名单",
        "quota_management": "Token 额度管理。支持总额度设置、已用额度追踪、额度重置（daily/weekly/monthly/never）。额度不足时拒绝请求",
        "permission_control": "模型访问权限控制。可限制每个 Key 只能访问特定模型。空列表表示允许所有模型",
        "storage": "支持两种存储方式：1. file（配置文件，适合小规模）2. redis（高性能，适合大规模）"
      }
    },
    "rate_limiting": {
      "enabled": true,
      "documentation": "基础限流控制。功能包括：1. 全局 QPS 限制（保护推理服务）2. API Key 级 QPS 限制（防止单个 Key 滥用）3. 并发数限制（防止资源耗尽）4. Token 速率限制（TPM）。算法：令牌桶（支持突发流量）。存储：Redis（分布式）或内存（单机）。配置示例见 docs/design-rate-limiting.md",
      "components": {
        "global_limit": "全局 QPS/QPM 限制，保护后端推理服务不被打垮。支持突发流量（burst_size）",
        "key_limit": "API Key 级限流。支持：1. requests_per_second（QPS）2. requests_per_minute（QPM）3. tokens_per_minute（TPM）4. max_concurrent（最大并发数）",
        "algorithm": "令牌桶算法。支持突发流量，平滑限流。使用 Redis Lua 脚本实现原子操作",
        "response_headers": "标准 HTTP 限流响应头：X-RateLimit-Limit、X-RateLimit-Remaining、X-RateLimit-Reset、Retry-After"
      }
    },
    "multi_tenancy": {
      "enabled": false,
      "documentation": "多租户功能未启用。当前通过 API Key 实现简单的多用户隔离"
    }
  },
  "logging": {
    "format": "structured_json",
    "documentation": "使用结构化日志（JSON 格式），便于日志聚合和分析。日志级别：INFO、WARN、ERROR。关键日志点：1. 请求开始/结束 2. 后端选择 3. Webhook 上报成功/失败 4. 健康检查状态变化"
  }
}
